# 事物管理

### 传统的spring配置

```properties
<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
		<property name="nestedTransactionAllowed" value="true"/><!-- 允许事务嵌套 -->
</bean>
//指明事物管理的数据源
<tx:annotation-driven proxy-target-class="true" />
//开启事物
```

### springboot配置,JavaBean配置

```java
@EnableTransactionManagement //开启事物功能
@SpringBootApplication
public class ProfiledemoApplication {

    // 其中 dataSource 框架会自动为我们注入
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    } 

    public static void main(String[] args) {
        SpringApplication.run(ProfiledemoApplication.class, args);
    }
}
```



###  **事务隔离级别**

**隔离级别是指若干个并发事务之间的隔离程度。**

**Spring Boot的隔离级别被封装在枚举类Isolation，枚举值取自接口TransactionDefinition 定义，该接口中定义了五个表示隔离级别的常量：**

|        **隔离级别**        |                           **含义**                           |
| :------------------------: | :----------------------------------------------------------: |
|     ISOLATION_DEFAULT      |             默认值，使用后端数据库默认的隔离级别             |
| ISOLATION_READ_UNCOMMITTED | 表示一个事务可以读取另一个事务修改但还没有提交的数据。可能导致脏读，不可重复读和幻读，因此很少使用该隔离级别。最低的隔离级别。 |
|  ISOLATION_READ_COMMITTED  | 表示一个事务只能读取另一个事务已经提交的数据。可以防止脏读，但是幻读或不可重复读仍有可能发生，这也是大多数情况下的推荐值。 |
| ISOLATION_REPEATABLE_READ  | 表示一个事务在整个过程中可以多次重复执行某个查询并且每次返回的记录都相同。可以防止脏读和不可重复读，但幻读仍有可能发生。MySQL默认隔离级别。 |
|   ISOLATION_SERIALIZABLE   | 所有的事务依次逐个执行，事务之间完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能，因为它通常是通过完全锁定事务相关的数据库表来实现的。 |

### **事务传播规则**

**事务传播行为（propagation behavior）用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时候，事务如何传播。**

**传播行为定义了事务范围，何时触发事务，是否暂停现有事务，或者在调用方法是如果没有事务则失败等等。**

**Spring Boot的事务传播行为常量被封装在枚举类Propagation，枚举值取自接口TransactionDefinition，在接口中定义了如下七个表示传播行为的常量：**

|       **传播行为**        |                           **含义**                           |
| :-----------------------: | :----------------------------------------------------------: |
|   PROPAGATION_REQUIRED    | 如果当前存在事务，则加入该事务；否则，新建一个事务。这是默认值 |
| PROPAGATION_REQUIRES_NEW  |          新建事务，如果当前存在事务，则挂起当前事务          |
|   PROPAGATION_SUPPORTS    | 如果当前存在事务，则加入该事务；否则，以非事务的方式继续运行 |
| PROPAGATION_NOT_SUPPORTED |      以非事务方式运行，如果当前存在事务，则挂起当前事务      |
|     PROPAGATION_NEVER     |         以非事务方式运行，如果当前存在事务，则抛异常         |
|   PROPAGATION_MANDATORY   | 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常 |
|    PROPAGATION_NESTED     | 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于PROPAGATION_REQUIRED |

